use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, Balance, AccountId};
use near_sdk::collections::UnorderedMap;
use crate::*;
use crate::account::{Account, AccountWithReward, AccountImpl, NumStakeShares};
use crate::{StorageKeys};
use uint::construct_uint;
use crate::views::HumanReadableAccount;
use crate::staking_utils::Fraction;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

pub trait StakingPool{
    fn get_total_staked_balance(&self) -> Balance;
    fn get_account_info(&self, account_id: &AccountId) -> HumanReadableAccount;
    fn deposit(&mut self, account_id: &AccountId, amount: Balance);
    fn withdraw(&mut self, account_id: &AccountId, amount: Balance) -> bool;
    fn stake(&mut self, account_id: &AccountId, amount: Balance, account_impl: &mut dyn AccountImpl) -> Balance;
    fn get_account_impl(&self, account_id: &AccountId) -> Box<dyn AccountImpl>;
    fn does_pool_stake_staking_rewards(&self) -> bool;

    fn unstake(&mut self, account_id: &AccountId, amount: Balance, account_impl: &mut dyn AccountImpl) -> Balance;

    fn save_account(&mut self, account_id: &AccountId, account_impl: &dyn AccountImpl);

    /// send rewards to receiver account id
    /// and remove account from account pool register if needed
    /// returns amount to send and flag indicating wether an account should be removed
    /// from register
    fn withdraw_not_staked_rewards(&mut self, account_id: &AccountId) -> (Balance, bool);
}

/// Structure containing information for accounts that have their rewards restaked
#[derive(BorshDeserialize, BorshSerialize)]
pub struct InnerStakingPool{
    /// The total amount of shares the staking pool has across the contract
    pub total_stake_shares: NumStakeShares,
    /// The total burn share balance, that will not be accounted in the farming.
    pub total_burn_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
}

/// Structure containing information for accounts that have their rewards not being restaked
#[derive(BorshDeserialize, BorshSerialize)]
pub struct InnerStakingPoolWithoutRewardsRestaked{
    pub accounts: UnorderedMap<AccountId, AccountWithReward>,
    /// Pool total staked balance
    pub total_staked_balance: Balance,
    /// Accounts deposit, it would be used when calculating how much of the total rewards is for each account
    /// and also how much of the total staked balance can be unstaked
    pub reward_per_token: Fraction,
    /// the total amount of rewards that are generated by the contract
    pub total_rewards: Balance,
    /// the amount of rewards that are actually unlocked and are in the contract
    pub total_buffered_rewards: Balance,
    /// the structure contains the rewards generated per epoch and are not yet available to
    /// withdraw. Those rewards are deleted from this mapping after they are included in
    /// `total_buffered_rewards`. The condition to include them is that the `epoch_height`
    /// must be epoch_height - 4 <= current_epoch_height.
    pub expected_rewards_in_epoch: UnorderedMap<EpochHeight, Balance>,
}

impl InnerStakingPool{
    /// Constructor
    pub fn new(
        stake_shares: NumStakeShares,
        staked_balance: Balance,
        total_burn_shares: NumStakeShares,
    ) -> Self{
        let this = Self{
            accounts: UnorderedMap::new(StorageKeys::Accounts),
            total_burn_shares: total_burn_shares,
            total_stake_shares: stake_shares,
            total_staked_balance: staked_balance
        };

        return this;
    }

    /// Inner method to get the given account or a new default value account.
    pub(crate) fn internal_get_account(&self, account_id: &AccountId) -> Account {
        let mut account = self.accounts.get(account_id).unwrap_or_default();
        account.is_burn_account = account_id.as_str() == ZERO_ADDRESS;
        account
    }

    /// Inner method to save the given account for a given account ID.
    /// If the account balances are 0, the account is deleted instead to release storage.
    /// Returns true or false wether the account was removed
    pub(crate) fn internal_save_account(&mut self, account_id: &AccountId, account: &Account) -> bool {
        if account.unstaked > 0 || account.stake_shares > 0 || account.amounts.len() > 0 {
            self.accounts.insert(account_id, &account);
            return false;
        } else {
            self.accounts.remove(account_id);
            return true;
        }
    }

    /// Returns the number of "stake" shares rounded down corresponding to the given staked balance
    /// amount.
    ///
    /// price = total_staked / total_shares
    /// Price is fixed
    /// (total_staked + amount) / (total_shares + num_shares) = total_staked / total_shares
    /// (total_staked + amount) * total_shares = total_staked * (total_shares + num_shares)
    /// amount * total_shares = total_staked * num_shares
    /// num_shares = amount * total_shares / total_staked
    pub(crate) fn num_shares_from_staked_amount_rounded_down(
        &self,
        amount: Balance,
    ) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        (U256::from(self.total_stake_shares) * U256::from(amount)
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the number of "stake" shares rounded up corresponding to the given staked balance
    /// amount.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn num_shares_from_staked_amount_rounded_up(
        &self,
        amount: Balance,
    ) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        ((U256::from(self.total_stake_shares) * U256::from(amount)
            + U256::from(self.total_staked_balance - 1))
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the staked amount rounded down corresponding to the given number of "stake" shares.
    pub(crate) fn staked_amount_from_num_shares_rounded_down(
        &self,
        num_shares: NumStakeShares,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        (U256::from(self.total_staked_balance) * U256::from(num_shares)
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Returns the staked amount rounded up corresponding to the given number of "stake" shares.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn staked_amount_from_num_shares_rounded_up(
        &self,
        num_shares: NumStakeShares,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        ((U256::from(self.total_staked_balance) * U256::from(num_shares)
            + U256::from(self.total_stake_shares - 1))
            / U256::from(self.total_stake_shares))
        .as_u128()
    }
}

impl InnerStakingPoolWithoutRewardsRestaked{
    /// Constructor
    pub fn new() -> Self{
        return Self {
            reward_per_token: Fraction::new(0, 1),
            total_staked_balance: 0,
            total_buffered_rewards: 0,
            total_rewards: 0,
            accounts: UnorderedMap::new(StorageKeys::AccountsNotStakedStakingPool),
            expected_rewards_in_epoch: UnorderedMap::new(StorageKeys::ExpectedTokensInEpoch),
        };
    }

    /// Inner method to get the given account or a new default value account.
    pub(crate) fn internal_get_account(&self, account_id: &AccountId) -> AccountWithReward {
        self.accounts.get(account_id).unwrap_or_default()
    }

    /// Inner method to save the given account for a given account ID.
    /// If the account balances are 0, the account is deleted instead to release storage.
    /// Returns true or false, wether the account was removeds
    pub(crate) fn internal_save_account(&mut self, account_id: &AccountId, account: &AccountWithReward) -> bool{
        if account.unstaked > 0 || 
            account.stake_shares > 0 || 
            account.amounts.len() > 0 || 
            ( account.reward_tally - account.payed_reward ) != 0 {
            self.accounts.insert(account_id, &account);
            return false;
        } else {
            self.accounts.remove(account_id);
            return true;
        }
    }

    /// Calculates the total rewards ready to be buffered.
    /// Returns the accumulated rewards that is ready to be claimed by the stakers.
    pub(crate) fn calculate_rewards_ready_to_buffer(&mut self, last_epoch_height: u64){
        let mut accumulated_rewards_from_not_staking_rewards: Balance = 0;

        let rewards_in_epoch = self.expected_rewards_in_epoch
            .iter()
            .filter(|el| (*el).0 <= last_epoch_height)
            .collect::<Vec<(u64, Balance)>>();

        for reward in rewards_in_epoch{
            accumulated_rewards_from_not_staking_rewards += reward.1;

            self.expected_rewards_in_epoch.remove(&reward.0);
        }

        self.total_buffered_rewards += accumulated_rewards_from_not_staking_rewards;
    }

    /// Distribute rewards by updating the reward_per_token 
    pub(crate) fn distribute_reward(&mut self, reward:Balance){
        if reward == 0{
            return;
        }
        assert!(self.total_staked_balance > 0, "Cannot distribute reward when staked balance is 0");
        self.total_rewards += reward;
        self.reward_per_token.add(Fraction::new(reward, self.total_staked_balance));
    }

    /// Calculate the total reward that a staker generated.
    pub(crate) fn compute_possible_reward(&self, account: &AccountWithReward) -> Balance {
        let reward: Balance;
        if account.tally_below_zero {
            reward = self.reward_per_token.multiply(account.stake_shares) + account.reward_tally;
        }else{
            reward = self.reward_per_token.multiply(account.stake_shares) - account.reward_tally;
        }

        return reward - account.payed_reward;
    }

    /// Calculate the total reward that a staker can withdraw during the current epoch.
    pub(crate) fn compute_reward(&self, account: &AccountWithReward) -> Balance{
        let reward: Balance;
        let buffered_rewards_ratio = Fraction::new(self.total_buffered_rewards, self.total_rewards );

        if account.tally_below_zero {
            reward = self.reward_per_token.multiply(account.stake_shares) + account.reward_tally;
        }else{
            reward = self.reward_per_token.multiply(account.stake_shares) - account.reward_tally;
        }

        return buffered_rewards_ratio.multiply(reward) - account.payed_reward;
    }
}

impl StakingPool for InnerStakingPool{
    fn get_total_staked_balance(&self) -> Balance {
        return self.total_staked_balance;
    }

    fn does_pool_stake_staking_rewards(&self) -> bool {
        return true;
    }

    fn get_account_impl(&self, account_id: &AccountId) -> Box<dyn AccountImpl> {
        let account = self.internal_get_account(&account_id);
        return Box::new(account);
    }

    fn get_account_info(&self, account_id: &AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        return HumanReadableAccount {
            account_id: account_id.clone(),
            unstaked_balance: account.unstaked.into(),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            can_withdraw: account.unstaked_available_epoch_height <= env::epoch_height(),
            rewards_for_withdraw: 0.into(),
            possible_rewards: 0.into(),
        }
    }

    fn deposit(&mut self, account_id: &AccountId, amount: Balance) {
        let mut account = self.internal_get_account(&account_id);
        
        account.unstaked += amount;
        self.internal_save_account(&account_id, &account);

        log!(
            "@{} deposited {}. New unstaked balance is {}",
            account_id,
            amount,
            account.unstaked
        );
    }

    fn withdraw_not_staked_rewards(&mut self, _account_id: &AccountId) -> (Balance, bool){
        return (0, false);
    }

    fn withdraw(&mut self, account_id: &AccountId, amount: Balance) -> bool{
        let mut account = self.internal_get_account(&account_id);
        assert!(
            account.unstaked >= amount,
            "Not enough unstaked balance to withdraw"
        );
        assert!(
            account.unstaked_available_epoch_height <= env::epoch_height(),
            "The unstaked balance is not yet available due to unstaking delay"
        );
        account.unstaked -= amount;
        let account_has_been_removed = self.internal_save_account(&account_id, &account);

        log!(
            "@{} withdrawing {}. New unstaked balance is {}",
            account_id,
            amount,
            account.unstaked
        );

        return account_has_been_removed;
    }

    fn stake(&mut self, account_id: &AccountId, amount: Balance, account_impl: &mut dyn AccountImpl) -> Balance {
        let account = account_impl
                                        .as_any_mut()
                                        .downcast_mut::<Account>()
                                        .unwrap();
        
        let num_shares = self.num_shares_from_staked_amount_rounded_down(amount);
        assert!(
            num_shares > 0,
            "The calculated number of \"stake\" shares received for staking should be positive"
        );
        // The amount of tokens the account will be charged from the unstaked balance.
        // Rounded down to avoid overcharging the account to guarantee that the account can always
        // unstake at least the same amount as staked.
        let charge_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);
        assert!(
            charge_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        assert!(
            account.unstaked >= charge_amount,
            "Not enough unstaked balance to stake"
        );
        account.unstaked -= charge_amount;
        account.stake_shares += num_shares;
        self.internal_save_account(&account_id, &account);

        // The staked amount that will be added to the total to guarantee the "stake" share price
        // never decreases. The difference between `stake_amount` and `charge_amount` is paid
        // from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let stake_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);

        self.total_staked_balance += stake_amount;
        self.total_stake_shares += num_shares;

        log!(
            "@{} staking {}. Received {} new staking shares. Total {} unstaked balance and {} \
             staking shares",
            account_id,
            charge_amount,
            num_shares,
            account.unstaked,
            account.stake_shares
        );
        log!(
            "Contract total staked balance is {}. Total number of shares {}",
            self.total_staked_balance,
            self.total_stake_shares
        );

        return charge_amount;
    }

    fn unstake(&mut self, account_id: &AccountId, amount: Balance, account_impl: &mut dyn AccountImpl) -> Balance{
        let account = account_impl
                                        .as_any_mut()
                                        .downcast_mut::<Account>()
                                        .unwrap();

        assert!(
            self.total_staked_balance > 0,
            "The contract doesn't have staked balance"
        );
        // Calculate the number of shares required to unstake the given amount.
        // NOTE: The number of shares the account will pay is rounded up.
        let num_shares = self.num_shares_from_staked_amount_rounded_up(amount);
        assert!(
            num_shares > 0,
            "Invariant violation. The calculated number of \"stake\" shares for unstaking should be positive"
        );
        assert!(
            account.stake_shares >= num_shares,
            "Not enough staked balance to unstake"
        );

        // Calculating the amount of tokens the account will receive by unstaking the corresponding
        // number of "stake" shares, rounding up.
        let receive_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);
        assert!(
            receive_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        account.stake_shares -= num_shares;
        account.unstaked += receive_amount;
        account.unstaked_available_epoch_height = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK;
        self.internal_save_account(&account_id, &account);

        // The amount tokens that will be unstaked from the total to guarantee the "stake" share
        // price never decreases. The difference between `receive_amount` and `unstake_amount` is
        // paid from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let unstake_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);

        self.total_staked_balance -= unstake_amount;
        self.total_stake_shares -= num_shares;
        if account.is_burn_account {
            self.total_burn_shares -= num_shares;
        }

        log!(
            "@{} unstaking {}. Spent {} staking shares. Total {} unstaked balance and {} \
             staking shares",
            account_id,
            receive_amount,
            num_shares,
            account.unstaked,
            account.stake_shares
        );
        log!(
            "Contract total staked balance is {}. Total number of shares {}",
            self.total_staked_balance,
            self.total_stake_shares
        );

        return receive_amount;
    }

    fn save_account(&mut self, account_id: &AccountId, account_impl: &dyn AccountImpl) {
        let account = account_impl
                                        .as_any()
                                        .downcast_ref::<Account>()
                                        .unwrap();

        self.internal_save_account(account_id, &account);
    }

}

impl StakingPool for InnerStakingPoolWithoutRewardsRestaked{
    fn get_total_staked_balance(&self) -> Balance {
        return self.total_staked_balance;
    }

    fn does_pool_stake_staking_rewards(&self) -> bool {
        return false;
    }

    fn get_account_impl(&self, account_id: &AccountId) -> Box<dyn AccountImpl> {
        let account = self.internal_get_account(&account_id);
        return Box::new(account);
    }

    fn get_account_info(&self, account_id: &AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        let rewards_for_withdraw = 
            if account.stake_shares == 0 {
                account.reward_tally - account.payed_reward
            }else {
                self.compute_reward(&account)
            };
        return HumanReadableAccount {
            account_id: account_id.clone(),
            unstaked_balance: account.unstaked.into(),
            staked_balance: account.stake_shares.into(),
            can_withdraw: account.unstaked_available_epoch_height <= env::epoch_height(),
            rewards_for_withdraw: rewards_for_withdraw.into(),
            possible_rewards: self.compute_possible_reward(&account).into(),
        };
    }

    fn deposit(&mut self, account_id: &AccountId, amount: Balance) {
        let mut account = self.internal_get_account(&account_id);
        
        account.unstaked += amount;
        self.internal_save_account(&account_id, &account);

        log!(
            "@{} deposited {}. New unstaked balance is {}",
            account_id,
            amount,
            account.unstaked
        );
    }

    fn withdraw_not_staked_rewards(&mut self, account_id: &AccountId) -> (Balance, bool){
        let mut account = self.internal_get_account(&account_id);
        if account.stake_shares == 0 {
            assert!(
                account.unstaked_available_epoch_height <= env::epoch_height(),
                "The unstaked balance is not yet available due to unstaking delay"
            );

            // the reward that left to be payed to the account
            let reward = account.reward_tally - account.payed_reward;
            account.payed_reward += reward;
            self.internal_save_account(&account_id, &account);

            return (reward, false);
        }else{
            let reward = self.compute_reward(&account);
            account.payed_reward += reward;
            let account_was_removed = self.internal_save_account(&account_id, &account);

            return (reward, account_was_removed);
        }
    }

    fn withdraw(&mut self, account_id: &AccountId, amount: Balance) -> bool{
        let mut account = self.internal_get_account(&account_id);
        assert!(
            account.unstaked >= amount,
            "Not enough unstaked balance to withdraw"
        );
        assert!(
            account.unstaked_available_epoch_height <= env::epoch_height(),
            "The unstaked balance is not yet available due to unstaking delay"
        );
        account.unstaked -= amount;
        let account_has_been_removed = self.internal_save_account(&account_id, &account);

        log!(
            "@{} withdrawing {}. New unstaked balance is {}",
            account_id,
            amount,
            account.unstaked
        );

        return account_has_been_removed;
    }

    fn stake(&mut self, account_id: &AccountId, amount: Balance, account_impl: &mut dyn AccountImpl) -> Balance{
        assert!(amount > 0, "Staking amount should be positive");
        let account = account_impl
                                        .as_any_mut()
                                        .downcast_mut::<AccountWithReward>()
                                        .unwrap();
        account.unstaked -= amount;
        account.stake_shares += amount;
        account.add_to_tally(self.reward_per_token.multiply(amount));
        self.total_staked_balance+=amount;

        self.internal_save_account(account_id, &account);

        log!(
            "@{} staking {}. Total {} unstaked balance and {} staked amount",
            account_id, amount, account.unstaked, account.stake_shares
        );

        return amount;
    }

    fn unstake(&mut self, account_id: &AccountId, amount: Balance, account_impl: &mut dyn AccountImpl) -> Balance{
        let account = account_impl
                                        .as_any_mut()
                                        .downcast_mut::<AccountWithReward>()
                                        .unwrap();

        assert!(
            self.total_staked_balance > 0,
            "The contract doesn't have staked balance"
        );
        assert!(
            amount > 0,
            "The unstaking amount should be positive"
        );
        assert!(
            account.stake_shares >= amount,
            "Not enough staked balance to unstake"
        );

        account.stake_shares -= amount;
        account.unstaked += amount;
        account.subtract_from_tally(self.reward_per_token.multiply(amount));
        account.unstaked_available_epoch_height = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK;
        self.internal_save_account(&account_id, &account);

        self.total_staked_balance -= amount;

        log!(
            "@{} unstaking {}. Total {} unstaked balance and {} staking amount",
            account_id, amount, account.unstaked, account.stake_shares
        );
        log!(
            "Contract inner staking pool total staked balance is {}",
            self.total_staked_balance
        );

        return amount;
    }

    fn save_account(&mut self, account_id: &AccountId, account_impl: &dyn AccountImpl) {
        let account = account_impl
                                        .as_any()
                                        .downcast_ref::<AccountWithReward>()
                                        .unwrap();

        self.internal_save_account(account_id, &account);
    }
}